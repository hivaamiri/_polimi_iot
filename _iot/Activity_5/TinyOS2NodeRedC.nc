/*
#Randon numbers generated by TinyOS, sending by Node-Red via 
MQTT to Thingspeak #Node red and ThingSpeak project 
#IoT course 
#A.Y 2019-2020 
#Plitecnico di Milano 
#Hiva Amiri #Erfan Abbasi zadeh #Mohammad Javad Ebrahimpour
*/


#include "TinyOS2NodeRed.h"
#include "Timer.h"
#include "printf.h"

module sendAckC
{
    uses
    {
        interface Boot;  
        interface Random;     
        interface SplitControl;
        interface Receive;
        interface Timer<TMilli> as MilliTimer;
        interface AMPacket;
        interface Packet;
        interface AMSend;
    }
}

implementation
{
 
    message_t packet;
 



//#################### Boot Function ####################
    event void Boot.booted()
    {
        dbg("boot", "Node booted. Report from node: %u\n=======================================\n",TOS_NODE_ID);
        call SplitControl.start(); 

    }
//#################### SplitControl, startDone ####################

    event void SplitControl.startDone(error_t _ERRORresult)
    {
        if(_ERRORresult == SUCCESS) // if radio started successfully
        {
        	dbg("radio", "Turnning on radio ... \n");
            dbg("radio", "Radio is on now. \n");
            if(TOS_NODE_ID == 2 || TOS_NODE_ID == 3) // if this code is running on mote with the ID 1
            {
                dbg("role", "Node 1 starts sending ACK request... ----> execution time %s \n", sim_time_string());
                call MilliTimer.startPeriodic(_FREQUENNCY); //start a timer with the the period of _FREQUENNCY second
            }   
        }
        else
        {
            dbg("radio", "Turnning on faild, try again ... \n");        
            call SplitControl.start(); // otherwise try to start the radio again
        }
    }
//#################### SplitControl, stopDone ####################
    event void SplitControl.stopDone(error_t _ERRORresult){}
//#################### MilliTimer function ####################
    event void MilliTimer.fired()
    {
        _messageToSend_t* MSG = (_messageToSend_t*)(call Packet.getPayload(&packet,sizeof(_messageToSend_t)));
        MSG -> _MoteID = TOS_NODE_ID; // send mote ID 
        MSG -> _dataMessage = (call Random.rand16()) % _REDUCE_RANGE;//generate random numbers between 0 and _REDUCE_RANGE
        dbg("radio_send", "Sending a response to node 1 ----> execution time %s \n", sim_time_string());
        if(call AMSend.send(1,&packet, sizeof(_messageToSend_t))==SUCCESS)// send msg to mote 1
        {
            dbg("radio_send", "Payload data:\n"); 
            dbg_clear("radio_pack","\t Counter valuse : %hhu \n ",MSG->_MoteID);
            dbg_clear("radio_pack","\t Temperature    : %hhu \n ",MSG->_dataMessage);
            dbg_clear("radio_send","\n");
            dbg_clear("radio_pack","\n");        
        } 

    }

//#################### AMSend, sendDone ####################
    event void AMSend.sendDone(message_t* _rec_buffer, error_t _ERRORresult)
    {
        if(&packet == _rec_buffer && _ERRORresult == SUCCESS) // if packet was sent successfull
        {
            dbg("radio_send", "Message was sent successfully.\n");    
        }

    } 
//#################### Receive.recieve ####################
    event message_t* Receive.receive(message_t* _rec_buffer, void* payload, uint8_t len)
    {
        // should be run in NODE1 only
        if ( TOS_NODE_ID == 1)
        {
        _messageToSend_t* MSG = (_messageToSend_t*)payload;// make a _messageToSend_t* type variable and put the recived message into it
            dbg("radio_send", "Payload data:\n"); 
            dbg_clear("radio_pack","\t Counter valuse : %hhu \n ",MSG->_MoteID);
            dbg_clear("radio_pack","\t Temperature    : %hhu \n ",MSG->_dataMessage);
            dbg_clear("radio_send","\n");
            dbg_clear("radio_pack","\n");
            //make a unic format to better separation in NODERED
            printf("Mote%u/value,%u,\n", MSG -> _MoteID, MSG -> _dataMessage);
            printfflush();
        }
        return _rec_buffer;
    } 
}
